<!doctype html>
<html lang="en">

<head>
		<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
		<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">


		<script src="js/three.js"></script>
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script>
		<script src="js/jquery-ui.min.js"></script>
		<script src="js/THREEx.FullScreen.js"></script>
		<script src="js/THREEx.KeyboardState.js"></script>
		<script src="js/leap.min.js"></script>	
		


		<!--blur-->
		<script src="js/EffectComposer.js"></script>
		<script src="js/RenderPass.js"></script>
		<script src="js/ShaderPass.js"></script>
		<script src="js/MaskPass.js"></script>
		<script src="js/CopyShader.js"></script>
		


		<!--dots-->
		<script src="js/DotScreenShader.js"></script>
		<script src="js/DotScreenPass.js"></script>
		<script src="js/HorizontalBlurShader.js"></script>
		<script src="js/VerticalBlurShader.js"></script>

	<style>
		#container 
			{
				background: #000;
				width: 100%;
				height: 100%;
				margin: 0px;
				overflow: hidden;
			}
		 #hurt 
		 	{
		      background-color: red;
		      display: none;
		      left: 0;
		      opacity: 0.15;
		      pointer-events: none;
		      position: absolute;
		      top: 0;
		      z-index: 1002;
    		}

    		    #hud 
    		{
		      bottom: 10px;
		      position: absolute;
		      right: 10px;
		      z-index: 100;
		    }

		    #aim
		    {
		    	pointer-events: none;
		    	position: absolute;
		    	z-index: 100;
		    	left:45%;
		    	top:45%;
		    	
		    }

		    #aimimg
		    {
		    	width:20%;
		    }


	</style>


		

	</head>
		
	<body>

		<div id="container">
			
		</div>




	 </body>


	 <script>
		//-----------------------LEAP STUF---------




				// set the scene size
				var WIDTH = window.innerWidth,
				  HEIGHT = window.innerHeight;

				// set some camera attributes
				var VIEW_ANGLE = 45,
				  ASPECT = WIDTH / HEIGHT,
				  NEAR = 0.1,
				  FAR = 10000;

				// get the DOM element to attach to
				// - assume we've got jQuery to hand
				var $container = $('#container');

				var clock = new THREE.Clock();

				// create a WebGL renderer, camera
				// and a scene
				var renderer = new THREE.WebGLRenderer();

				var camera =
				  new THREE.PerspectiveCamera(
				    VIEW_ANGLE,
				    ASPECT,
				    NEAR,
				    FAR);

				var scene = new THREE.Scene();

				// add the camera to the scene
				scene.add(camera);

				rayC = new THREE.Raycaster();
                

                var lavaBall, floor, roof, testmesh;
                var bots = new Array(10);
                var health = 1000;





		// Initialize and run on document ready
		$(document).ready(function() {
			$('body').append('<div id="intro">Click to start</div>');
			$('#intro').css({width: WIDTH, height: HEIGHT}).one('click', function(e) {
				e.preventDefault();
				$(this).fadeOut();
				init();
				animate();
				startLeap();
				//setInterval(, 1000);
				
			});
		});





		 var leapvars =
		 {
		 	leapX: 50,
		 	leapY: 50,
		 	leapZ:100,
		 	leapDirX:0,
		 	leapDirY:0,
		 	leapDirZ:0,
		 	handRad:50
		 };
		
		 var camDir = new THREE.Vector3(0,0,0);
		 var lat = 0;
		 var lon = 0;
		 var fingerIn = false;

		 var previousFrame;


		 

		 


	

	function startLeap() 
	 {
				 // Setup Leap loop with frame callback function
			    var controller = new Leap.Controller({enableGestures: true});
			        var region = new Leap.UI.Region(
			          [0, 150, -100], 
			          [200, 250, 100]
			        );

				controller.addStep(new Leap.UI.Cursor())
				controller.addStep(region.listener({nearThreshold:50}));

				console.log("leap initialized");
				
	




				//BIG loop
				controller.loop(function(frame, done) {
		  		// Body of callback function

		  			//overall rotation
			  		if (typeof previousFrame == 'undefined')
			  		 {
			  		 	previousFrame = frame;
			  		 }
			  		 else
			  		 {
			  			  var rotationAxis = frame.rotationAxis(previousFrame);
						  var rotationAngle = frame.rotationAngle(previousFrame);
						  var frameString;
						  frameString += "Rotation axis: " + rotationAxis + "<br />";
						  frameString += "Rotation angle: " + rotationAngle.toFixed(2) + " radians<br />";
						  //console.log(frameString);
						  
						  previousFrame = frame;
					}


					


					//pointer
					if (frame.cursorPosition) {
				      	leap_enabled = true;
				      	fingerIn = true;

				        var leapPosition = region.mapToXY(frame.cursorPosition, 500, 500);

				        leapvars.leapX = (leapPosition[0]);
				        leapvars.leapY = (leapPosition[1]);
				        leapvars.leapZ = leapPosition[2];
				   
				      }
				      else
				      {
				      	fingerIn = false;
				      }

				      if(frame.pointables.length > 0)
				      {
				      	
				      	var pointable = frame.pointables[0];

				      	leapvars.leapDirX = -pointable.direction[0];
				      	leapvars.leapDirY = -pointable.direction[1];
				      	leapvars.leapDirZ = pointable.direction[2];

				      	 //console.log("Direction X:" + leapvars.leapDirX + "  Y:" + leapvars.leapDirY + "  Z:" + leapvars.leapDirZ );
				      	 
				      }
				

				      if (frame.hands.length > 0) {
				      var hand = frame.hands[0];

				      leapvars.handRad = hand.sphereRadius.toFixed(1);
				      
				  	  }
				    done();
				});
	}

		
		 //------------------------THREE D STUFF

		 function init()
		 {



					// the camera starts at 0,0,0
					// so pull it back
					camera.position.y = 10;

					camera.rotation.order = "YXZ";

					// start the renderer
					renderer.setSize(WIDTH, HEIGHT);

					projector = new THREE.Projector(); // A helper class for projecting 2D rays (on the screen) into 3D rays (in the virtual world)				


					// attach the render-supplied DOM element
					// Add the canvas to the document
					renderer.domElement.style.backgroundColor = '#000000'; // easier to see
					document.body.appendChild(renderer.domElement);
					
					THREEx.FullScreen.bindKey({ charCode : 'm'.charCodeAt(0) });


					


					

					// create a point light
					var pointLight =
					  new THREE.PointLight(0xFFFFFF);

					// set its position
					pointLight.position.x = 10;
					pointLight.position.y = 50;
					pointLight.position.z = 130;

					// add to the scene
					scene.add(pointLight);
					scene.fog = new THREE.FogExp2( 0x9999ff, 0.00025 );


					// set up the sphere vars
					var radius = 50,
					    segments = 16,
					    rings = 16;


					// basic lava ball
					var lavaTexture = THREE.ImageUtils.loadTexture( 'img/lava.jpg' );
					var lavaMaterial = new THREE.MeshBasicMaterial( { map: lavaTexture } );
					lavaBall = new THREE.Mesh(  new THREE.SphereGeometry(
					    radius,
					    segments,
					    rings), lavaMaterial );
					lavaBall.position.set(-100, 50, 250);
					scene.add( lavaBall );	


					// SUPER SIMPLE GLOW EFFECT  (not working!!!!!!!)
					// use sprite because it appears the same from all angles
					var spriteMaterial = new THREE.SpriteMaterial( 
					{ 
						map: new THREE.ImageUtils.loadTexture( 'img/glow.png' ), 
						useScreenCoordinates: false, alignment: THREE.SpriteAlignment.center, color: 0x0000ff, transparent: false, blending: THREE.AdditiveBlending
					});
					var glow = new THREE.Sprite( spriteMaterial );
					glow.scale.set(150, 150, 1.0);
					lavaBall.add(glow); // this centers the glow at the mesh




					//ROBOTS
						
					//textures
					var botTexture1 = THREE.ImageUtils.loadTexture( 'img/zrobotanim1.png' );
					//botanim = new TextureAnimator( botTexture1, 5, 1, 5, 120 ); // texture, #horiz, #vert, #total, duration.
					var botMaterial2 = new THREE.SpriteMaterial( { map: botTexture1, useScreenCoordinates: false, color: 0xff0000 } );
					var botMaterial1 = new THREE.SpriteMaterial( { map: botTexture1, useScreenCoordinates: false } );
					var botMaterial3 = new THREE.MeshBasicMaterial( { map: botTexture1, side:THREE.DoubleSide } );
					//positions
					console.log("botlength: " + bots.length);
					for (var i = 0; i < bots.length; i++)
					{
						bots[i] = new THREE.Sprite( botMaterial1 );
						var posX = Math.random()*1000;
						var posZ = Math.random()*1000;
						bots[i].position.set( posX, 10, posZ );
						bots[i].scale.set( 34, 40, 1.0 ); // imageWidth, imageHeight
						scene.add( bots[i] );
						console.log ("bot number " + i);


						// botGeometry = new THREE.PlaneGeometry(34, 40, 1, 1);
						// bots[i] = new THREE.Mesh(botGeometry, botMaterial3);
						// var posX = Math.random()*1000;
						// var posZ = Math.random()*1000;
						// bots[i].position.set( posX, 10, posZ );
						// //bots[i].scale.set( 34, 40, 1.0 );
						// scene.add( bots[i] );
						// console.log ("bot number " + i);
					}







					//aimMark       (not working!!!!!!!)
					//




					// Shoot on click
					$(document).click(function(e) {
						e.preventDefault;
						if (e.which === 1) { // Left click only
							piw();
						}
					});








					// Set up the brief red flash that shows when you get hurt
					$('body').append('<div id="hurt"></div>');

					$('body').append('<div id="hud"><p>Health: <span id="health">100</span></p></div>');

					$('body').append('<div id="aim"><img id="aimimg" src="img/aim2.png"></div>');
					//$("#aimimg").style.top=HEIGHT/2;
					//$("#aimimg").style.height=HEIGHT/20;



					//FLOOR w TEXTURE
					var floorTexture = new THREE.ImageUtils.loadTexture( 'img/scrn3.gif' );
					floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping; 
					floorTexture.repeat.set(60,60);
					//floorTexture.anisotropy =20;
					var floorMaterial = new THREE.MeshBasicMaterial( { map: floorTexture, color: 0xCCCC99} );
					var floorGeometry = new THREE.PlaneGeometry(1000, 1000, 10, 10);
					floor = new THREE.Mesh(floorGeometry, floorMaterial);
					floor.position.y = -10;
					floor.position.z = 250;
					floor.position.x = 250;
					floor.rotation.x = Math.PI *1.5;
					//floor.rotation.x = Math.PI / 2;
					scene.add(floor);

					//ROOF w TEXTURE
					var roofTexture = new THREE.ImageUtils.loadTexture( 'img/wall3.jpg' );
					roofTexture.wrapS = roofTexture.wrapT = THREE.RepeatWrapping; 
					roofTexture.repeat.set(20,20);
					//roofTexture.anisotropy =20;
					var roofMaterial = new THREE.MeshBasicMaterial( { map: roofTexture} );
					var roofGeometry = new THREE.PlaneGeometry(1000, 1000, 10, 10);
					roof = new THREE.Mesh(roofGeometry, roofMaterial);
					roof.position.y = 100;
					roof.position.z = 250;
					roof.position.x = 250;
					roof.rotation.x = Math.PI / 2;
					//floor.rotation.x = Math.PI / 2;
					scene.add(roof);

					//WALL Texture 1
					var wallTexture1 = new THREE.ImageUtils.loadTexture( 'img/cables.jpg' );
					wallTexture1.wrapS = wallTexture1.wrapT = THREE.RepeatWrapping; 
					wallTexture1.repeat.set(20,2);
					var wallMaterial1 = new THREE.MeshBasicMaterial( { map: wallTexture1} );
					var wallGeometry = new THREE.PlaneGeometry(200, 200, 1, 1);
					wall1 = new THREE.Mesh(roofGeometry, roofMaterial);
					roof.position.y = 100;
					roof.position.z = 250;
					roof.position.x = 250;
					roof.rotation.x = Math.PI / 2;
					//floor.rotation.x = Math.PI / 2;
					scene.add(roof);



					
					//NO ANDA  LOAD JSONS
					var loader = new THREE.GeometryLoader();

					loader.load( "wallgeotest.json", function (geometry) 
					{
	    				var testmesh = new THREE.Mesh( geometry, floorMaterial);
	    				scene.add(testmesh);
	    				console.log("added test wall");
					});

					


			}


			function animate()
			{

				pointCam();
				animateStuff();
					


				//setBlur();    NEVER WORKED, but all code is in
				//setDotScreen();     NEVER WORKED, but all code is in






				//loop back and run this func again
				requestAnimFrame(animate);

				renderer.render(scene, camera);
				// place the rAF *before* the render() to assure as close to 60fps with the setTimeout fallback.

			}

			




				
				function onWindowResize() {

                        camera.aspect = window.innerWidth / window.innerHeight;
                        camera.updateProjectionMatrix();

                        renderer.setSize( window.innerWidth, window.innerHeight );

                }


				function pointCam()
				{

					if (fingerIn)
					{
						

						

						if (Math.abs(leapvars.leapDirX)>0.1)
						{
							lon -= leapvars.leapDirX;

						}
						if (Math.abs(leapvars.leapDirY)>0.1)
						{
							lat -= leapvars.leapDirY;

						}


						lat = Math.max( - 85, Math.min( 85, lat ) );
						phi = ( 90 - lat )* Math.PI / 180;;
						theta = ( lon )* Math.PI / 180;;

						camDir.y = 500 * Math.cos( phi );
						camDir.x = 500 * Math.sin( phi ) * Math.cos( theta );
						camDir.z = 500 * Math.sin( phi ) * Math.sin( theta );

						// var targetPosition = camera.target,
						// 	position = camera.position;


						// targetPosition.x = position.x + 500 * Math.sin( phi ) * Math.cos( theta );
						// targetPosition.y = position.y + 500 * Math.cos( phi );
						// targetPosition.z = position.z + 500 * Math.sin( phi ) * Math.sin( theta );

						//var normalCamDir = camDir.clone();
						//normalCamDir.normalize();

						if(leapvars.leapZ<0)
						{
							camera.translateZ(-1);
							camera.position.y = 10; 

						}

					}
					camera.lookAt(camDir);
					//var upvec = new THREE.Vector3(0,0,0);
					//camera.up = upvec;

					rayC.set(camera.position,camDir);
					
					var intersections = rayC.intersectObject( bots );


					if ( intersections.length > 0 ) {

                         enlamira();                       
                        
                    }

                    //console.log("current position - X: " + camera.position.x + " Y: " + camera.position.y + " Z: " + camera.position.z);

				}


				function enlamira()
				{
					console.log("algo en la mira");

				}

			
				function animateStuff()
				{	
					var delta = clock.getDelta(); 
					var xvec = new THREE.Vector3(0,1,0);
					lavaBall.rotateOnAxis(xvec,0.01);

					hurtYou();
					//walkToYou();

					//animate bot
					//botanim.update(1000*delta);
				}

				function hurtYou()
				{
					for (var i = 0; i < bots.length; i++)
					{
						if (distance2D(bots[i].position.x, bots[i].position.z, camera.position.x, camera.position.z) < 25) 
						{
							health -= 1;
							$('#hurt').fadeIn(75);
							// ... hurt the player ...
							$('#hurt').fadeOut(350);
							console.log("getting hurt by bot!");
						}
					}
				}

				function walkToYou()
				{
					//getDir
					//update their direction
					for (var i = 0; i < bots.length; i++)
					{ 
						
						//lookatyou
						bots[i].lookAt(camera.position);

						//walk 
						bots[i].translateZ(0.3);

					}
				}



				function piw()
				{
					console.log("PIW");
				}


				//NO FUNCA for kill you style  (has js imports)
				function setBlur()
				{
					composer = new THREE.EffectComposer( renderer );
					composer.addPass( new THREE.RenderPass( scene, camera ) );
					
					// http://devmaster.net/posts/3100/shader-effects-glow-bloom	
					// http://www.neilblevins.com/cg_education/specular_bloom/specular_bloom.htm
					var effectHorizBlur = new THREE.ShaderPass( THREE.HorizontalBlurShader );
					var effectVertiBlur = new THREE.ShaderPass( THREE.VerticalBlurShader );
					effectHorizBlur.uniforms[ "h" ].value = 2 / window.innerWidth;
					effectVertiBlur.uniforms[ "v" ].value = 2 / window.innerHeight;
					effectVertiBlur.renderToScreen = true;
					
					composer.addPass( effectHorizBlur );
					composer.addPass( effectVertiBlur );
					shaderActive = "blur";
				}

				// NO FUNCA for comicbook style  (has js imports)
				function setDotScreen()
				{
					composer = new THREE.EffectComposer( renderer );
					composer.addPass( new THREE.RenderPass( scene, camera ) );
					
					var effectDotScreen = new THREE.DotScreenPass( new THREE.Vector2(0,0), 1, 0.8 ); 
					effectDotScreen.renderToScreen = true; 
					composer.addPass(effectDotScreen); 
					shaderActive = "dotscreen";
				}

				function distance2D(aX, aZ, bX, bZ)
				{
					var dx = Math.abs(aX-bX);
					var dy = Math.abs(aZ-bZ);
					return Math.sqrt(Math.pow(dx,2)+Math.pow(dy,2));
				}

		 </script>

</html>